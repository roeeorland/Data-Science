
R version 3.3.2 (2016-10-31) -- "Sincere Pumpkin Patch"
Copyright (C) 2016 The R Foundation for Statistical Computing
Platform: i386-w64-mingw32/i386 (32-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> swirl()
Error: could not find function "swirl"
> install_from_swirl("R Programming")
Error: could not find function "install_from_swirl"
> library("swirl")

| Hi! Type swirl() when you are ready to begin.

> swirl()

| Welcome to swirl! Please sign in. If you've been here before, use the same
| name as you did then. If you are new, call yourself something unique.

What shall I call you? roeeorland

| Would you like to continue with one of these lessons?

1: R Programming Vectors
2: No. Let me start something new.

Selection: 1



| Vector recycling! Try paste(LETTERS, 1:4, sep = "-"), where LETTERS is a
| predefined variable in R containing a character vector of all 26 letters in
| the English alphabet.


> > k
Error: object 'k' not found
> swirl()

| Welcome to swirl! Please sign in. If you've been here before, use the same
| name as you did then. If you are new, call yourself something unique.

What shall I call you? roeeorland

| Would you like to continue with one of these lessons?

1: R Programming Vectors
2: No. Let me start something new.

Selection: 2

| Please choose a course, or type 0 to exit swirl.

1: R Programming
2: Take me to the swirl course repository!

Selection: 1

| Please choose a lesson, or type 0 to return to course menu.

 1: Basic Building Blocks      2: Workspace and Files     
 3: Sequences of Numbers       4: Vectors                 
 5: Missing Values             6: Subsetting Vectors      
 7: Matrices and Data Frames   8: Logic                   
 9: Functions                 10: lapply and sapply       
11: vapply and tapply         12: Looking at Data         
13: Simulation                14: Dates and Times         
15: Base Graphics             

Selection: 4

  |                                                                              |                                                                      |   0%

| The simplest and most common data structure in R is the vector.

...

  |                                                                              |==                                                                    |   3%
| Vectors come in two different flavors: atomic vectors and lists. An atomic
| vector contains exactly one data type, whereas a list may contain multiple
| data types. We'll explore atomic vectors further before we get to lists.

...

  |                                                                              |====                                                                  |   5%
| In previous lessons, we dealt entirely with numeric vectors, which are one
| type of atomic vector. Other types of atomic vectors include logical,
| character, integer, and complex. In this lesson, we'll take a closer look at
| logical and character vectors.

...

  |                                                                              |======                                                                |   8%
| Logical vectors can contain the values TRUE, FALSE, and NA (for 'not
| available'). These values are generated as the result of logical
| 'conditions'. Let's experiment with some simple conditions.

...

  |                                                                              |=======                                                               |  11%
| First, create a numeric vector num_vect that contains the values 0.5, 55,
| -10, and 6.

> num_vect(0.5,55,-10,6)
Error: could not find function "num_vect"
> num_vect<-c(0.5,55,-10,6)

| You got it right!

  |                                                                              |=========                                                             |  13%
| Now, create a variable called tf that gets the result of num_vect < 1, which
| is read as 'num_vect is less than 1'.

> tf<-num_vect<1

| Great job!

  |                                                                              |===========                                                           |  16%
| What do you think tf will look like?

1: a vector of 4 logical values
2: a single logical value

Selection: 1

| Nice work!

  |                                                                              |=============                                                         |  18%
| Print the contents of tf now.

> tf
[1]  TRUE FALSE  TRUE FALSE

| Keep up the great work!

  |                                                                              |===============                                                       |  21%
| The statement num_vect < 1 is a condition and tf tells us whether each
| corresponding element of our numeric vector num_vect satisfies this
| condition.

...

  |                                                                              |=================                                                     |  24%
| The first element of num_vect is 0.5, which is less than 1 and therefore the
| statement 0.5 < 1 is TRUE. The second element of num_vect is 55, which is
| greater than 1, so the statement 55 < 1 is FALSE. The same logic applies for
| the third and fourth elements.

...

  |                                                                              |==================                                                    |  26%
| Let's try another. Type num_vect >= 6 without assigning the result to a new
| variable.

> num_vect>=6
[1] FALSE  TRUE FALSE  TRUE

| Perseverance, that's the answer.

  |                                                                              |====================                                                  |  29%
| This time, we are asking whether each individual element of num_vect is
| greater than OR equal to 6. Since only 55 and 6 are greater than or equal to
| 6, the second and fourth elements of the result are TRUE and the first and
| third elements are FALSE.

...

  |                                                                              |======================                                                |  32%
| The `<` and `>=` symbols in these examples are called 'logical operators'.
| Other logical operators include `>`, `<=`, `==` for exact equality, and `!=`
| for inequality.

...

  |                                                                              |========================                                              |  34%
| If we have two logical expressions, A and B, we can ask whether at least one
| is TRUE with A | B (logical 'or' a.k.a. 'union') or whether they are both
| TRUE with A & B (logical 'and' a.k.a. 'intersection'). Lastly, !A is the
| negation of A and is TRUE when A is FALSE and vice versa.

...

  |                                                                              |==========================                                            |  37%
| It's a good idea to spend some time playing around with various combinations
| of these logical operators until you get comfortable with their use. We'll do
| a few examples here to get you started.

...

  |                                                                              |============================                                          |  39%
| Try your best to predict the result of each of the following statements. You
| can use pencil and paper to work them out if it's helpful. If you get stuck,
| just guess and you've got a 50% chance of getting the right answer!

...

  |                                                                              |=============================                                         |  42%
| (3 > 5) & (4 == 4)

1: FALSE
2: TRUE

Selection: 1

| You are really on a roll!

  |                                                                              |===============================                                       |  45%
| (TRUE == TRUE) | (TRUE == FALSE)

1: FALSE
2: TRUE

Selection: 2

| Great job!

  |                                                                              |=================================                                     |  47%
| ((111 >= 111) | !(TRUE)) & ((4 + 1) == 5)

1: FALSE
2: TRUE

Selection: 2

| Great job!

  |                                                                              |===================================                                   |  50%
| Don't worry if you found these to be tricky. They're supposed to be. Working
| with logical statements in R takes practice, but your efforts will be
| rewarded in future lessons (e.g. subsetting and control structures).

...

  |                                                                              |=====================================                                 |  53%
| Character vectors are also very common in R. Double quotes are used to
| distinguish character objects, as in the following example.

...

  |                                                                              |=======================================                               |  55%
| Create a character vector that contains the following words: "My", "name",
| "is". Remember to enclose each word in its own set of double quotes, so that
| R knows they are character strings. Store the vector in a variable called
| my_char.

> my_char<-c("My","name","is")

| You are amazing!

  |                                                                              |=========================================                             |  58%
| Print the contents of my_char to see what it looks like.

> my_char
[1] "My"   "name" "is"  

| You nailed it! Good job!

  |                                                                              |==========================================                            |  61%
| Right now, my_char is a character vector of length 3. Let's say we want to
| join the elements of my_char together into one continuous character string
| (i.e. a character vector of length 1). We can do this using the paste()
| function.

...

  |                                                                              |============================================                          |  63%
| Type paste(my_char, collapse = " ") now. Make sure there's a space between
| the double quotes in the `collapse` argument. You'll see why in a second.

> paste(my_char,collapse=" ")
[1] "My name is"

| You're the best!

  |                                                                              |==============================================                        |  66%
| The `collapse` argument to the paste() function tells R that when we join
| together the elements of the my_char character vector, we'd like to separate
| them with single spaces.

...

  |                                                                              |================================================                      |  68%
| It seems that we're missing something.... Ah, yes! Your name!

...

  |                                                                              |==================================================                    |  71%
| To add (or 'concatenate') your name to the end of my_char, use the c()
| function like this: c(my_char, "your_name_here"). Place your name in double
| quotes where I've put "your_name_here". Try it now, storing the result in a
| new variable called my_name.

> my_name<-c(my_char,"Ro'ee Orland")

| Keep up the great work!

  |                                                                              |====================================================                  |  74%
| Take a look at the contents of my_name.

> my_name
[1] "My"           "name"         "is"           "Ro'ee Orland"

| You got it right!

  |                                                                              |=====================================================                 |  76%
| Now, use the paste() function once more to join the words in my_name together
| into a single character string. Don't forget to say collapse = " "!

> paste(my_name,collapse=" ")
[1] "My name is Ro'ee Orland"

| You got it right!

  |                                                                              |=======================================================               |  79%
| In this example, we used the paste() function to collapse the elements of a
| single character vector. paste() can also be used to join the elements of
| multiple character vectors.

...

  |                                                                              |=========================================================             |  82%
| In the simplest case, we can join two character vectors that are each of
| length 1 (i.e. join two words). Try paste("Hello", "world!", sep = " "),
| where the `sep` argument tells R that we want to separate the joined elements
| with a single space.

> paste("Hello","world!",sep=" ")
[1] "Hello world!"

| You are quite good my friend!

  |                                                                              |===========================================================           |  84%
| For a slightly more complicated example, we can join two vectors, each of
| length 3. Use paste() to join the integer vector 1:3 with the character
| vector c("X", "Y", "Z"). This time, use sep = "" to leave no space between
| the joined elements.

> paste(1:3,c("X","Y","Z"),sep="")
[1] "1X" "2Y" "3Z"

| You got it!

  |                                                                              |=============================================================         |  87%
| What do you think will happen if our vectors are of different length? (Hint:
| we talked about this in a previous lesson.)

...

  |                                                                              |===============================================================       |  89%
| Vector recycling! Try paste(LETTERS, 1:4, sep = "-"), where LETTERS is a
| predefined variable in R containing a character vector of all 26 letters in
| the English alphabet.

> paste(LETTERS,1:4,sep="-")
 [1] "A-1" "B-2" "C-3" "D-4" "E-1" "F-2" "G-3" "H-4" "I-1" "J-2" "K-3" "L-4"
[13] "M-1" "N-2" "O-3" "P-4" "Q-1" "R-2" "S-3" "T-4" "U-1" "V-2" "W-3" "X-4"
[25] "Y-1" "Z-2"

| You're the best!

  |                                                                              |================================================================      |  92%
| Since the character vector LETTERS is longer than the numeric vector 1:4, R
| simply recycles, or repeats, 1:4 until it matches the length of LETTERS.

...

  |                                                                              |==================================================================    |  95%
| Also worth noting is that the numeric vector 1:4 gets 'coerced' into a
| character vector by the paste() function.

...

  |                                                                              |====================================================================  |  97%
| We'll discuss coercion in another lesson, but all it really means is that the numbers 1, 2, 3, and 4 in the output above are no longer numbers to R, but rather
| characters "1", "2", "3", and "4".

...

  |                                                                              |======================================================================| 100%
| Would you like to receive credit for completing this course on Coursera.org?

1: Yes
2: No

Selection: 1
What is your email address? roee.orland@gmail.com
What is your assignment token? xxcP9D6T1pekSopg
Grade submission succeeded!

| That's the answer I was looking for.

| You've reached the end of this lesson! Returning to the main menu...

| Please choose a course, or type 0 to exit swirl.

1: R Programming
2: Take me to the swirl course repository!

Selection: 1

| Please choose a lesson, or type 0 to return to course menu.

 1: Basic Building Blocks      2: Workspace and Files        3: Sequences of Numbers       4: Vectors                    5: Missing Values          
 6: Subsetting Vectors         7: Matrices and Data Frames   8: Logic                      9: Functions                 10: lapply and sapply       
11: vapply and tapply         12: Looking at Data           13: Simulation                14: Dates and Times           15: Base Graphics           


Selection: 5

  |                                                                                                                                                                     |                                                                                                                                                             |   0%

| Missing values play an important role in statistics and data analysis. Often, missing values must not be ignored, but rather they should be carefully studied to see
| if there's an underlying pattern or cause for their missingness.

...

  |                                                                                                                                                                     |========                                                                                                                                                     |   5%
| In R, NA is used to represent any value that is 'not available' or 'missing' (in the statistical sense). In this lesson, we'll explore missing values further.

...

  |                                                                                                                                                                     |================                                                                                                                                             |  10%
| Any operation involving NA generally yields NA as the result. To illustrate, let's create a vector c(44, NA, 5, NA) and assign it to a variable x.

> x<-c(44,NA,5,NA)

| You nailed it! Good job!

  |                                                                                                                                                                     |========================                                                                                                                                     |  15%
| Now, let's multiply x by 3.

> x*3
[1] 132  NA  15  NA

| Your dedication is inspiring!

  |                                                                                                                                                                     |===============================                                                                                                                              |  20%
| Notice that the elements of the resulting vector that correspond with the NA values in x are also NA.

...

  |                                                                                                                                                                     |=======================================                                                                                                                      |  25%
| To make things a little more interesting, lets create a vector containing 1000 draws from a standard normal distribution with y <- rnorm(1000).

> y<-rnorm(1000)

| That's correct!

  |                                                                                                                                                                     |===============================================                                                                                                              |  30%
| Next, let's create a vector containing 1000 NAs with z <- rep(NA, 1000).

> z<-rep(NA,1000)

| That's a job well done!

  |                                                                                                                                                                     |=======================================================                                                                                                      |  35%
| Finally, let's select 100 elements at random from these 2000 values (combining y and z) such that we don't know how many NAs we'll wind up with or what positions
| they'll occupy in our final vector -- my_data <- sample(c(y, z), 100).

> my_data<-sample(c(y,z),100)

| Keep up the great work!

  |                                                                                                                                                                     |===============================================================                                                                                              |  40%
| Let's first ask the question of where our NAs are located in our data. The is.na() function tells us whether each element of a vector is NA. Call is.na() on my_data
| and assign the result to my_na.

> my_na<-is.na(my_data)

| Nice work!

  |                                                                                                                                                                     |=======================================================================                                                                                      |  45%
| Now, print my_na to see what you came up with.

> my_na
  [1] FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE
 [28]  TRUE  TRUE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE  TRUE
 [55]  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE
 [82]  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE

| You got it right!

  |                                                                                                                                                                     |==============================================================================                                                                               |  50%
| Everywhere you see a TRUE, you know the corresponding element of my_data is NA. Likewise, everywhere you see a FALSE, you know the corresponding element of my_data
| is one of our random draws from the standard normal distribution.

...

  |                                                                                                                                                                     |======================================================================================                                                                       |  55%
| In our previous discussion of logical operators, we introduced the `==` operator as a method of testing for equality between two objects. So, you might think the
| expression my_data == NA yields the same results as is.na(). Give it a try.

> my_data==NA
  [1] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA
 [55] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA

| All that practice is paying off!

  |                                                                                                                                                                     |==============================================================================================                                                               |  60%
| The reason you got a vector of all NAs is that NA is not really a value, but just a placeholder for a quantity that is not available. Therefore the logical
| expression is incomplete and R has no choice but to return a vector of the same length as my_data that contains all NAs.

...

  |                                                                                                                                                                     |======================================================================================================                                                       |  65%
| Don't worry if that's a little confusing. The key takeaway is to be cautious when using logical expressions anytime NAs might creep in, since a single NA value can
| derail the entire thing.

...

  |                                                                                                                                                                     |==============================================================================================================                                               |  70%
| So, back to the task at hand. Now that we have a vector, my_na, that has a TRUE for every NA and FALSE for every numeric value, we can compute the total number of
| NAs in our data.

...

  |                                                                                                                                                                     |======================================================================================================================                                       |  75%
| The trick is to recognize that underneath the surface, R represents TRUE as the number 1 and FALSE as the number 0. Therefore, if we take the sum of a bunch of
| TRUEs and FALSEs, we get the total number of TRUEs.

...

  |                                                                                                                                                                     |==============================================================================================================================                               |  80%
| Let's give that a try here. Call the sum() function on my_na to count the total number of TRUEs in my_na, and thus the total number of NAs in my_data. Don't assign
| the result to a new variable.

> sum(my_na)
[1] 45

| Perseverance, that's the answer.

  |                                                                                                                                                                     |=====================================================================================================================================                        |  85%
| Pretty cool, huh? Finally, let's take a look at the data to convince ourselves that everything 'adds up'. Print my_data to the console.

> my_data
  [1]  0.31016359 -0.73496303          NA          NA  1.48751753 -0.55845505 -0.13040016 -0.04483497  1.91240274          NA          NA  1.42005352          NA
 [14]  0.94992589 -0.13010351  1.04600016          NA  0.67405654 -0.53006525          NA  0.45537462 -0.13159689          NA          NA  1.76670073 -0.46523117
 [27]  1.08811469          NA          NA  0.20597080          NA  0.23873991  0.13970631          NA -0.79221272  1.22822264          NA  0.28236933          NA
 [40] -0.34296157  0.32899434 -0.07946970          NA  1.33924655          NA          NA -1.13296233  0.46895297          NA          NA  1.42812016  0.36791781
 [53]          NA          NA          NA -0.31337803 -1.10417134  0.38673662          NA  0.80420209 -0.53415887          NA -0.89219293 -0.14227863          NA
 [66]          NA          NA          NA  0.45829181  1.47391277 -0.66405514 -1.56759561 -0.11924194 -0.27959984          NA          NA  0.77872122 -0.38987051
 [79] -0.51248762          NA          NA          NA          NA -0.01705886  1.00523072          NA          NA -0.30715303 -1.20536643          NA -0.13763280
 [92]          NA -0.75802081          NA          NA          NA          NA          NA  0.65249409          NA

| Nice work!

  |                                                                                                                                                                     |=============================================================================================================================================                |  90%
| Now that we've got NAs down pat, let's look at a second type of missing value -- NaN, which stands for 'not a number'. To generate NaN, try dividing (using a
| forward slash) 0 by 0 now.

> 0/0
[1] NaN

| Excellent job!

  |                                                                                                                                                                     |=====================================================================================================================================================        |  95%
| Let's do one more, just for fun. In R, Inf stands for infinity. What happens if you subtract Inf from Inf?

> Inf-Inf
[1] NaN

| You got it!

  |                                                                                                                                                                     |=============================================================================================================================================================| 100%
| Would you like to receive credit for completing this course on Coursera.org?

1: Yes
2: No

Selection: 1
What is your email address? roee.orland@gmail.com
What is your assignment token? 6SX287Lb5dHJSS3i
Grade submission succeeded!

| Perseverance, that's the answer.

| You've reached the end of this lesson! Returning to the main menu...

| Please choose a course, or type 0 to exit swirl.

1: R Programming
2: Take me to the swirl course repository!

Selection: 1

| Please choose a lesson, or type 0 to return to course menu.

 1: Basic Building Blocks      2: Workspace and Files        3: Sequences of Numbers       4: Vectors                    5: Missing Values          
 6: Subsetting Vectors         7: Matrices and Data Frames   8: Logic                      9: Functions                 10: lapply and sapply       
11: vapply and tapply         12: Looking at Data           13: Simulation                14: Dates and Times           15: Base Graphics           


Selection: History(Inf)
Enter an item from the menu, or 0 to exit
Selection: 6

  |                                                                                                                                                                     |                                                                                                                                                             |   0%

| In this lesson, we'll see how to extract elements from a vector based on some conditions that we specify.

...

  |                                                                                                                                                                     |====                                                                                                                                                         |   3%
| For example, we may only be interested in the first 20 elements of a vector, or only the elements that are not NA, or only those that are positive or correspond to
| a specific variable of interest. By the end of this lesson, you'll know how to handle each of these scenarios.

...

  |                                                                                                                                                                     |========                                                                                                                                                     |   5%
| I've created for you a vector called x that contains a random ordering of 20 numbers (from a standard normal distribution) and 20 NAs. Type x now to see what it
| looks like.

> x
 [1] -1.525539694 -2.734154083           NA -1.062015337           NA           NA -0.399800405 -1.868204547 -0.969668552           NA           NA           NA
[13]           NA  1.069543738           NA -0.855506020           NA           NA           NA  0.892884359           NA  0.620178541           NA           NA
[25]  1.192894458  1.059073700 -1.062793482 -0.595352714  1.293713211           NA  1.000554126           NA           NA           NA -0.054820366           NA
[37]  0.570503324           NA -0.007443856 -0.607158990

| All that practice is paying off!

  |                                                                                                                                                                     |============                                                                                                                                                 |   8%
| The way you tell R that you want to select some particular elements (i.e. a 'subset') from a vector is by placing an 'index vector' in square brackets immediately
| following the name of the vector.

...

  |                                                                                                                                                                     |================                                                                                                                                             |  10%
| For a simple example, try x[1:10] to view the first ten elements of x.

> x[1:10]
 [1] -1.5255397 -2.7341541         NA -1.0620153         NA         NA -0.3998004 -1.8682045 -0.9696686         NA

| That's the answer I was looking for.

  |                                                                                                                                                                     |====================                                                                                                                                         |  13%
| Index vectors come in four different flavors -- logical vectors, vectors of positive integers, vectors of negative integers, and vectors of character strings --
| each of which we'll cover in this lesson.

...

  |                                                                                                                                                                     |========================                                                                                                                                     |  15%
| Let's start by indexing with logical vectors. One common scenario when working with real-world data is that we want to extract all elements of a vector that are not
| NA (i.e. missing data). Recall that is.na(x) yields a vector of logical values the same length as x, with TRUEs corresponding to NA values in x and FALSEs
| corresponding to non-NA values in x.

...

  |                                                                                                                                                                     |============================                                                                                                                                 |  18%
| What do you think x[is.na(x)] will give you?

1: A vector of length 0
2: A vector of TRUEs and FALSEs
3: A vector of all NAs
4: A vector with no NAs

Selection: 1

| Try again. Getting it right on the first try is boring anyway!

| Remember that is.na(x) tells us where the NAs are in a vector. So if we subset x based on that, what do you expect to happen?

1: A vector of all NAs
2: A vector of length 0
3: A vector with no NAs
4: A vector of TRUEs and FALSEs

Selection: 4

| You're close...I can feel it! Try it again.

| Remember that is.na(x) tells us where the NAs are in a vector. So if we subset x based on that, what do you expect to happen?

1: A vector of TRUEs and FALSEs
2: A vector of length 0
3: A vector with no NAs
4: A vector of all NAs

Selection: 4

| You are amazing!

  |                                                                                                                                                                     |================================                                                                                                                             |  21%
| Prove it to yourself by typing x[is.na(x)].

> x[is.na(x)]
 [1] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA

| Keep working like that and you'll get there!

  |                                                                                                                                                                     |====================================                                                                                                                         |  23%
| Recall that `!` gives us the negation of a logical expression, so !is.na(x) can be read as 'is not NA'. Therefore, if we want to create a vector called y that
| contains all of the non-NA values from x, we can use y <- x[!is.na(x)]. Give it a try.

> y<-c(!is.na(x))

| Try again. Getting it right on the first try is boring anyway! Or, type info() for more options.

| Type y <- x[!is.na(x)] to capture all non-missing values from x.

> y<-x[!is.na(x)])
Error: unexpected ')' in "y<-x[!is.na(x)])"
> y<-x[!is.na(x)]

| That's correct!

  |                                                                                                                                                                     |========================================                                                                                                                     |  26%
| Print y to the console.

> y
 [1] -1.525539694 -2.734154083 -1.062015337 -0.399800405 -1.868204547 -0.969668552  1.069543738 -0.855506020  0.892884359  0.620178541  1.192894458  1.059073700
[13] -1.062793482 -0.595352714  1.293713211  1.000554126 -0.054820366  0.570503324 -0.007443856 -0.607158990

| Excellent job!

  |                                                                                                                                                                     |============================================                                                                                                                 |  28%
| Now that we've isolated the non-missing values of x and put them in y, we can subset y as we please.

...

  |                                                                                                                                                                     |================================================                                                                                                             |  31%
| Recall that the expression y > 0 will give us a vector of logical values the same length as y, with TRUEs corresponding to values of y that are greater than zero
| and FALSEs corresponding to values of y that are less than or equal to zero. What do you think y[y > 0] will give you?

1: A vector of all the positive elements of y
2: A vector of length 0
3: A vector of all the negative elements of y
4: A vector of all NAs
5: A vector of TRUEs and FALSEs

Selection: 1

| Excellent work!

  |                                                                                                                                                                     |====================================================                                                                                                         |  33%
| Type y[y > 0] to see that we get all of the positive elements of y, which are also the positive elements of our original vector x.

> y[y>0]
[1] 1.0695437 0.8928844 0.6201785 1.1928945 1.0590737 1.2937132 1.0005541 0.5705033

| Your dedication is inspiring!

  |                                                                                                                                                                     |========================================================                                                                                                     |  36%
| You might wonder why we didn't just start with x[x > 0] to isolate the positive elements of x. Try that now to see why.

> x[x>0]
 [1]        NA        NA        NA        NA        NA        NA        NA 1.0695437        NA        NA        NA        NA 0.8928844        NA 0.6201785        NA
[17]        NA 1.1928945 1.0590737 1.2937132        NA 1.0005541        NA        NA        NA        NA 0.5705033        NA

| You are doing so well!

  |                                                                                                                                                                     |============================================================                                                                                                 |  38%
| Since NA is not a value, but rather a placeholder for an unknown quantity, the expression NA > 0 evaluates to NA. Hence we get a bunch of NAs mixed in with our
| positive numbers when we do this.

...

  |                                                                                                                                                                     |================================================================                                                                                             |  41%
| Combining our knowledge of logical operators with our new knowledge of subsetting, we could do this -- x[!is.na(x) & x > 0]. Try it out.

> x[!is.na(x)&x>0]
[1] 1.0695437 0.8928844 0.6201785 1.1928945 1.0590737 1.2937132 1.0005541 0.5705033

| That's correct!

  |                                                                                                                                                                     |====================================================================                                                                                         |  44%
| In this case, we request only values of x that are both non-missing AND greater than zero.

...

  |                                                                                                                                                                     |========================================================================                                                                                     |  46%
| I've already shown you how to subset just the first ten values of x using x[1:10]. In this case, we're providing a vector of positive integers inside of the square
| brackets, which tells R to return only the elements of x numbered 1 through 10.

...

  |                                                                                                                                                                     |============================================================================                                                                                 |  49%
| Many programming languages use what's called 'zero-based indexing', which means that the first element of a vector is considered element 0. R uses 'one-based
| indexing', which (you guessed it!) means the first element of a vector is considered element 1.

...

  |                                                                                                                                                                     |=================================================================================                                                                            |  51%
| Can you figure out how we'd subset the 3rd, 5th, and 7th elements of x? Hint -- Use the c() function to specify the element numbers as a numeric vector.

> c(x[3],x[5],x[7])
[1]         NA         NA -0.3998004

| You're close...I can feel it! Try it again. Or, type info() for more options.

| Create a vector of indexes with c(3, 5, 7), then put that inside of the square brackets.

> x[c(3,5,7)]
[1]         NA         NA -0.3998004

| Great job!

  |                                                                                                                                                                     |=====================================================================================                                                                        |  54%
| It's important that when using integer vectors to subset our vector x, we stick with the set of indexes {1, 2, ..., 40} since x only has 40 elements. What happens
| if we ask for the zeroth element of x (i.e. x[0])? Give it a try.

> x[0]
numeric(0)

| Excellent work!

  |                                                                                                                                                                     |=========================================================================================                                                                    |  56%
| As you might expect, we get nothing useful. Unfortunately, R doesn't prevent us from doing this. What if we ask for the 3000th element of x? Try it out.

> x[3000]
[1] NA

| Excellent work!

  |                                                                                                                                                                     |=============================================================================================                                                                |  59%
| Again, nothing useful, but R doesn't prevent us from asking for it. This should be a cautionary tale. You should always make sure that what you are asking for is
| within the bounds of the vector you're working with.

...

  |                                                                                                                                                                     |=================================================================================================                                                            |  62%
| What if we're interested in all elements of x EXCEPT the 2nd and 10th? It would be pretty tedious to construct a vector containing all numbers 1 through 40 EXCEPT 2
| and 10.

...

  |                                                                                                                                                                     |=====================================================================================================                                                        |  64%
| Luckily, R accepts negative integer indexes. Whereas x[c(2, 10)] gives us ONLY the 2nd and 10th elements of x, x[c(-2, -10)] gives us all elements of x EXCEPT for
| the 2nd and 10 elements.  Try x[c(-2, -10)] now to see this.

> x[c(-2,-10)]
 [1] -1.525539694           NA -1.062015337           NA           NA -0.399800405 -1.868204547 -0.969668552           NA           NA           NA  1.069543738
[13]           NA -0.855506020           NA           NA           NA  0.892884359           NA  0.620178541           NA           NA  1.192894458  1.059073700
[25] -1.062793482 -0.595352714  1.293713211           NA  1.000554126           NA           NA           NA -0.054820366           NA  0.570503324           NA
[37] -0.007443856 -0.607158990

| You are amazing!

  |                                                                                                                                                                     |=========================================================================================================                                                    |  67%
| A shorthand way of specifying multiple negative numbers is to put the negative sign out in front of the vector of positive numbers. Type x[-c(2, 10)] to get the
| exact same result.

> x[-c(2,10)]
 [1] -1.525539694           NA -1.062015337           NA           NA -0.399800405 -1.868204547 -0.969668552           NA           NA           NA  1.069543738
[13]           NA -0.855506020           NA           NA           NA  0.892884359           NA  0.620178541           NA           NA  1.192894458  1.059073700
[25] -1.062793482 -0.595352714  1.293713211           NA  1.000554126           NA           NA           NA -0.054820366           NA  0.570503324           NA
[37] -0.007443856 -0.607158990

| You nailed it! Good job!

  |                                                                                                                                                                     |=============================================================================================================                                                |  69%
| So far, we've covered three types of index vectors -- logical, positive integer, and negative integer. The only remaining type requires us to introduce the concept
| of 'named' elements.

...

  |                                                                                                                                                                     |=================================================================================================================                                            |  72%
| Create a numeric vector with three named elements using vect <- c(foo = 11, bar = 2, norf = NA).

> vect<-c(foo=11,bar=2,norf=NA)

| That's correct!

  |                                                                                                                                                                     |=====================================================================================================================                                        |  74%
| When we print vect to the console, you'll see that each element has a name. Try it out.

> vect
 foo  bar norf 
  11    2   NA 

| All that hard work is paying off!

  |                                                                                                                                                                     |=========================================================================================================================                                    |  77%
| We can also get the names of vect by passing vect as an argument to the names() function. Give that a try.

> names(vect)
[1] "foo"  "bar"  "norf"

| Excellent job!

  |                                                                                                                                                                     |=============================================================================================================================                                |  79%
| Alternatively, we can create an unnamed vector vect2 with c(11, 2, NA). Do that now.

> vect2<-c(11,2,NA)

| Excellent job!

  |                                                                                                                                                                     |=================================================================================================================================                            |  82%
| Then, we can add the `names` attribute to vect2 after the fact with names(vect2) <- c("foo", "bar", "norf"). Go ahead.

> names(vect2)<-c("foo","bar","norf")

| You're the best!

  |                                                                                                                                                                     |=====================================================================================================================================                        |  85%
| Now, let's check that vect and vect2 are the same by passing them as arguments to the identical() function.

> identical(vect,vect2)
[1] TRUE

| All that practice is paying off!

  |                                                                                                                                                                     |=========================================================================================================================================                    |  87%
| Indeed, vect and vect2 are identical named vectors.

...

  |                                                                                                                                                                     |=============================================================================================================================================                |  90%
| Now, back to the matter of subsetting a vector by named elements. Which of the following commands do you think would give us the second element of vect?

1: vect[bar]
2: vect["bar"]
3: vect["2"]

Selection: 2

| You are amazing!

  |                                                                                                                                                                     |=================================================================================================================================================            |  92%
| Now, try it out.

> vect["bar"]
bar 
  2 

| All that practice is paying off!

  |                                                                                                                                                                     |=====================================================================================================================================================        |  95%
| Likewise, we can specify a vector of names with vect[c("foo", "bar")]. Try it out.

> vect[c("foo","bar")]
foo bar 
 11   2 

| You got it right!

  |                                                                                                                                                                     |=========================================================================================================================================================    |  97%
| Now you know all four methods of subsetting data from vectors. Different approaches are best in different scenarios and when in doubt, try it out!

...

  |                                                                                                                                                                     |=============================================================================================================================================================| 100%
| Would you like to receive credit for completing this course on Coursera.org?

1: No
2: Yes

Selection: 2
What is your email address? roee.orland@gmail.com
What is your assignment token? xyXjVvZOAWRbgBOU
Grade submission succeeded!

| You are really on a roll!

| You've reached the end of this lesson! Returning to the main menu...

| Please choose a course, or type 0 to exit swirl.

1: R Programming
2: Take me to the swirl course repository!

Selection: 1

| Please choose a lesson, or type 0 to return to course menu.

 1: Basic Building Blocks      2: Workspace and Files        3: Sequences of Numbers       4: Vectors                    5: Missing Values          
 6: Subsetting Vectors         7: Matrices and Data Frames   8: Logic                      9: Functions                 10: lapply and sapply       
11: vapply and tapply         12: Looking at Data           13: Simulation                14: Dates and Times           15: Base Graphics           


Selection: 7

  |                                                                                                                                                                     |                                                                                                                                                             |   0%

| In this lesson, we'll cover matrices and data frames. Both represent 'rectangular' data types, meaning that they are used to store tabular data, with rows and
| columns.

...

  |                                                                                                                                                                     |====                                                                                                                                                         |   3%
| The main difference, as you'll see, is that matrices can only contain a single class of data, while data frames can consist of many different classes of data.

...

  |                                                                                                                                                                     |=========                                                                                                                                                    |   6%
| Let's create a vector containing the numbers 1 through 20 using the `:` operator. Store the result in a variable called my_vector.

> my_vector<-1:20

| That's the answer I was looking for.

  |                                                                                                                                                                     |=============                                                                                                                                                |   8%
| View the contents of the vector you just created.

> my_vector
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20

| You got it right!

  |                                                                                                                                                                     |=================                                                                                                                                            |  11%
| The dim() function tells us the 'dimensions' of an object. What happens if we do dim(my_vector)? Give it a try.

> dim(my_vector)
NULL

| Perseverance, that's the answer.

  |                                                                                                                                                                     |======================                                                                                                                                       |  14%
| Clearly, that's not very helpful! Since my_vector is a vector, it doesn't have a `dim` attribute (so it's just NULL), but we can find its length using the length()
| function. Try that now.

> length(my_vector)
[1] 20

| You are quite good my friend!

  |                                                                                                                                                                     |==========================                                                                                                                                   |  17%
| Ah! That's what we wanted. But, what happens if we give my_vector a `dim` attribute? Let's give it a try. Type dim(my_vector) <- c(4, 5).

> dim(my_vector)<-c(4,5)

| You got it!

  |                                                                                                                                                                     |===============================                                                                                                                              |  19%
| It's okay if that last command seemed a little strange to you. It should! The dim() function allows you to get OR set the `dim` attribute for an R object. In this
| case, we assigned the value c(4, 5) to the `dim` attribute of my_vector.

...

  |                                                                                                                                                                     |===================================                                                                                                                          |  22%
| Use dim(my_vector) to confirm that we've set the `dim` attribute correctly.

> dim(my_vector)
[1] 4 5

| Keep up the great work!

  |                                                                                                                                                                     |=======================================                                                                                                                      |  25%
| Another way to see this is by calling the attributes() function on my_vector. Try it now.

> attributes(my_vector)
$dim
[1] 4 5


| You got it!

  |                                                                                                                                                                     |============================================                                                                                                                 |  28%
| Just like in math class, when dealing with a 2-dimensional object (think rectangular table), the first number is the number of rows and the second is the number of
| columns. Therefore, we just gave my_vector 4 rows and 5 columns.

...

  |                                                                                                                                                                     |================================================                                                                                                             |  31%
| But, wait! That doesn't sound like a vector any more. Well, it's not. Now it's a matrix. View the contents of my_vector now to see what it looks like.

> my_vector
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    5    9   13   17
[2,]    2    6   10   14   18
[3,]    3    7   11   15   19
[4,]    4    8   12   16   20

| Excellent work!

  |                                                                                                                                                                     |====================================================                                                                                                         |  33%
| Now, let's confirm it's actually a matrix by using the class() function. Type class(my_vector) to see what I mean.

> class(my_vector)
[1] "matrix"

| That's correct!

  |                                                                                                                                                                     |=========================================================                                                                                                    |  36%
| Sure enough, my_vector is now a matrix. We should store it in a new variable that helps us remember what it is. Store the value of my_vector in a new variable
| called my_matrix.

> my_matrix<-my_vector

| Your dedication is inspiring!

  |                                                                                                                                                                     |=============================================================                                                                                                |  39%
| The example that we've used so far was meant to illustrate the point that a matrix is simply an atomic vector with a dimension attribute. A more direct method of
| creating the same matrix uses the matrix() function.

...

  |                                                                                                                                                                     |=================================================================                                                                                            |  42%
| Bring up the help file for the matrix() function now using the `?` function.

> ?matrix
starting httpd help server ... done

| Keep up the great work!

  |                                                                                                                                                                     |======================================================================                                                                                       |  44%
| Now, look at the documentation for the matrix function and see if you can figure out how to create a matrix containing the same numbers (1-20) and dimensions (4
| rows, 5 columns) by calling the matrix() function. Store the result in a variable called my_matrix2.

> my_matrix2<-matrix(1:20,nrow=4,ncol=5)

| Nice work!

  |                                                                                                                                                                     |==========================================================================                                                                                   |  47%
| Finally, let's confirm that my_matrix and my_matrix2 are actually identical. The identical() function will tell us if its first two arguments are the same. Try it
| out.

> identical(my_matrix,my_matrix2)
[1] TRUE

| All that practice is paying off!

  |                                                                                                                                                                     |==============================================================================                                                                               |  50%
| Now, imagine that the numbers in our table represent some measurements from a clinical experiment, where each row represents one patient and each column represents
| one variable for which measurements were taken.

...

  |                                                                                                                                                                     |===================================================================================                                                                          |  53%
| We may want to label the rows, so that we know which numbers belong to each patient in the experiment. One way to do this is to add a column to the matrix, which
| contains the names of all four people.

...

  |                                                                                                                                                                     |=======================================================================================                                                                      |  56%
| Let's start by creating a character vector containing the names of our patients -- Bill, Gina, Kelly, and Sean. Remember that double quotes tell R that something is
| a character string. Store the result in a variable called patients.

> patients<-c("bill","Gina","Kelly","Sean")

| You're close...I can feel it! Try it again. Or, type info() for more options.

| Make sure to capitalize the first letter of each name and to store the result in a variable called patients. Also, don't get the order of the patients mixed up!
| That would be a disaster!

> patients<-c("Bill","Gina","Kelly","Sean")

| Your dedication is inspiring!

  |                                                                                                                                                                     |============================================================================================                                                                 |  58%
| Now we'll use the cbind() function to 'combine columns'. Don't worry about storing the result in a new variable. Just call cbind() with two arguments -- the
| patients vector and my_matrix.

> cbind(patients,my_matrix)
     patients                       
[1,] "Bill"   "1" "5" "9"  "13" "17"
[2,] "Gina"   "2" "6" "10" "14" "18"
[3,] "Kelly"  "3" "7" "11" "15" "19"
[4,] "Sean"   "4" "8" "12" "16" "20"

| That's correct!

  |                                                                                                                                                                     |================================================================================================                                                             |  61%
| Something is fishy about our result! It appears that combining the character vector with our matrix of numbers caused everything to be enclosed in double quotes.
| This means we're left with a matrix of character strings, which is no good.

...

  |                                                                                                                                                                     |====================================================================================================                                                         |  64%
| If you remember back to the beginning of this lesson, I told you that matrices can only contain ONE class of data. Therefore, when we tried to combine a character
| vector with a numeric matrix, R was forced to 'coerce' the numbers to characters, hence the double quotes.

...

  |                                                                                                                                                                     |=========================================================================================================                                                    |  67%
| This is called 'implicit coercion', because we didn't ask for it. It just happened. But why didn't R just convert the names of our patients to numbers? I'll let you
| ponder that question on your own.

...

  |                                                                                                                                                                     |=============================================================================================================                                                |  69%
| So, we're still left with the question of how to include the names of our patients in the table without destroying the integrity of our numeric data. Try the
| following -- my_data <- data.frame(patients, my_matrix)

> my_data<-data.frame(patients, my_matrix)

| Great job!

  |                                                                                                                                                                     |=================================================================================================================                                            |  72%
| Now view the contents of my_data to see what we've come up with.

> my_data
  patients X1 X2 X3 X4 X5
1     Bill  1  5  9 13 17
2     Gina  2  6 10 14 18
3    Kelly  3  7 11 15 19
4     Sean  4  8 12 16 20

| You nailed it! Good job!

  |                                                                                                                                                                     |======================================================================================================================                                       |  75%
| It looks like the data.frame() function allowed us to store our character vector of names right alongside our matrix of numbers. That's exactly what we were hoping
| for!

...

  |                                                                                                                                                                     |==========================================================================================================================                                   |  78%
| Behind the scenes, the data.frame() function takes any number of arguments and returns a single object of class `data.frame` that is composed of the original
| objects.

...

  |                                                                                                                                                                     |==============================================================================================================================                               |  81%
| Let's confirm this by calling the class() function on our newly created data frame.

> class(my_data)
[1] "data.frame"

| You got it!

  |                                                                                                                                                                     |===================================================================================================================================                          |  83%
| It's also possible to assign names to the individual rows and columns of a data frame, which presents another possible way of determining which row of values in our
| table belongs to each patient.

...

  |                                                                                                                                                                     |=======================================================================================================================================                      |  86%
| However, since we've already solved that problem, let's solve a different problem by assigning names to the columns of our data frame so that we know what type of
| measurement each column represents.

...

  |                                                                                                                                                                     |============================================================================================================================================                 |  89%
| Since we have six columns (including patient names), we'll need to first create a vector containing one element for each column. Create a character vector called
| cnames that contains the following values (in order) -- "patient", "age", "weight", "bp", "rating", "test".

> cnames<-c("patient","age","weight","bp","rating","test")

| You are quite good my friend!

  |                                                                                                                                                                     |================================================================================================================================================             |  92%
| Now, use the colnames() function to set the `colnames` attribute for our data frame. This is similar to the way we used the dim() function earlier in this lesson.

> colnames(my_data,cnames)
Error in is.data.frame(x) && do.NULL : invalid 'y' type in 'x && y'
> colnames(cnames,my_data)
Error in if (do.NULL) NULL else if (nc > 0L) paste0(prefix, seq_len(nc)) else character() : 
  argument is not interpretable as logical
In addition: Warning message:
In if (do.NULL) NULL else if (nc > 0L) paste0(prefix, seq_len(nc)) else character() :
  the condition has length > 1 and only the first element will be used
> ?colnames
> colnames(my_data)<-cnames

| Excellent work!

  |                                                                                                                                                                     |====================================================================================================================================================         |  94%
| Let's see if that got the job done. Print the contents of my_data.

> my_data
  patient age weight bp rating test
1    Bill   1      5  9     13   17
2    Gina   2      6 10     14   18
3   Kelly   3      7 11     15   19
4    Sean   4      8 12     16   20

| You are really on a roll!

  |                                                                                                                                                                     |=========================================================================================================================================================    |  97%
| In this lesson, you learned the basics of working with two very important and common data structures -- matrices and data frames. There's much more to learn and
| we'll be covering more advanced topics, particularly with respect to data frames, in future lessons.

...

  |                                                                                                                                                                     |=============================================================================================================================================================| 100%
| Would you like to receive credit for completing this course on Coursera.org?

1: No
2: Yes

Selection: 
