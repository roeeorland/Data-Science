
R version 3.3.2 (2016-10-31) -- "Sincere Pumpkin Patch"
Copyright (C) 2016 The R Foundation for Statistical Computing
Platform: i386-w64-mingw32/i386 (32-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

[Previously saved workspace restored]

> x<-c(1,2,NA)
> x
[1]  1  2 NA
> mean(x)
[1] NA
> mean(x,rm.na)
Error in mean.default(x, rm.na) : object 'rm.na' not found
> mean(x,na.rm)
Error in mean.default(x, na.rm) : object 'na.rm' not found
> mean(x,NA.rm)
Error in mean.default(x, NA.rm) : object 'NA.rm' not found
> mean(x,rm.NA)
Error in mean.default(x, rm.NA) : object 'rm.NA' not found
> mean(x,rm.NA=True)
[1] NA
> mean(c(x[!is.na]))
Error in !is.na : invalid argument type
> x[!is.na)]
Error: unexpected ')' in "x[!is.na)"
> x[is.na)]
Error: unexpected ')' in "x[is.na)"
> x[(is.na)]
Error in x[(is.na)] : invalid subscript type 'builtin'
> x[is.na]
Error in x[is.na] : invalid subscript type 'builtin'
> x[is.na(x)]
[1] NA
> x
[1]  1  2 NA
> x[x[!is.na(x)]]
[1] 1 2
> mean(x[x[!is.na(x)]])
[1] 1.5
> c<-c(1,2)
> c
[1] 1 2
> c(1,2,3)
[1] 1 2 3
> c
[1] 1 2
> swirl()
Error: could not find function "swirl"
> library("swirl")

| Hi! I see that you have some variables saved in your workspace. To keep things running smoothly, I recommend you clean up before starting swirl.

| Type ls() to see a list of the variables in your workspace. Then, type rm(list=ls()) to clear your workspace.

| Type swirl() when you are ready to begin.

> swirl()

| Welcome to swirl! Please sign in. If you've been here before, use the same name as you did then. If you are new, call yourself something unique.

What shall I call you? roeeorland

| Please choose a course, or type 0 to exit swirl.

1: R Programming
2: Take me to the swirl course repository!

Selection: 1

| Please choose a lesson, or type 0 to return to course menu.

 1: Basic Building Blocks      2: Workspace and Files        3: Sequences of Numbers       4: Vectors                    5: Missing Values          
 6: Subsetting Vectors         7: Matrices and Data Frames   8: Logic                      9: Functions                 10: lapply and sapply       
11: vapply and tapply         12: Looking at Data           13: Simulation                14: Dates and Times           15: Base Graphics           


Selection: 14

  |                                                                                                                                                                     |                                                                                                                                                             |   0%

| R has a special way of representing dates and times, which can be helpful if you're working with data that show how something changes over time (i.e. time-series
| data) or if your data contain some other temporal information, like dates of birth.

...

  |                                                                                                                                                                     |====                                                                                                                                                         |   3%
| Dates are represented by the 'Date' class and times are represented by the 'POSIXct' and 'POSIXlt' classes. Internally, dates are stored as the number of days since
| 1970-01-01 and times are stored as either the number of seconds since 1970-01-01 (for 'POSIXct') or a list of seconds, minutes, hours, etc. (for 'POSIXlt').

...

  |                                                                                                                                                                     |=========                                                                                                                                                    |   6%
| Let's start by using d1 <- Sys.Date() to get the current date and store it in the variable d1. (That's the letter 'd' and the number 1.)

> d1<-Sys.Date()

| You got it!

  |                                                                                                                                                                     |=============                                                                                                                                                |   8%
| Use the class() function to confirm d1 is a Date object.

> class(d1)
[1] "Date"

| Excellent work!

  |                                                                                                                                                                     |=================                                                                                                                                            |  11%
| We can use the unclass() function to see what d1 looks like internally. Try it out.

> unclass(d1)
[1] 17237

| Perseverance, that's the answer.

  |                                                                                                                                                                     |======================                                                                                                                                       |  14%
| That's the exact number of days since 1970-01-01!

...

  |                                                                                                                                                                     |==========================                                                                                                                                   |  17%
| However, if you print d1 to the console, you'll get today's date -- YEAR-MONTH-DAY. Give it a try.

> d1
[1] "2017-03-12"

| Nice work!

  |                                                                                                                                                                     |===============================                                                                                                                              |  19%
| What if we need to reference a date prior to 1970-01-01? Create a variable d2 containing as.Date("1969-01-01").

> d2<-as.Date("1969-01-01")

| You are really on a roll!

  |                                                                                                                                                                     |===================================                                                                                                                          |  22%
| Now use unclass() again to see what d2 looks like internally.

> unclass(d2)
[1] -365

| Nice work!

  |                                                                                                                                                                     |=======================================                                                                                                                      |  25%
| As you may have anticipated, you get a negative number. In this case, it's -365, since 1969-01-01 is exactly one calendar year (i.e. 365 days) BEFORE 1970-01-01.

...

  |                                                                                                                                                                     |============================================                                                                                                                 |  28%
| Now, let's take a look at how R stores times. You can access the current date and time using the Sys.time() function with no arguments. Do this and store the result
| in a variable called t1.

> t1<-Sys.time()

| You got it right!

  |                                                                                                                                                                     |================================================                                                                                                             |  31%
| View the contents of t1.

> unclass(t1)
[1] 1489350145

| You almost had it, but not quite. Try again. Or, type info() for more options.

| Type t1 to view its contents.

> t1
[1] "2017-03-12 22:22:25 IST"

| Your dedication is inspiring!

  |                                                                                                                                                                     |====================================================                                                                                                         |  33%
| And check the class() of t1.

> class(t)
[1] "function"

| Not quite right, but keep trying. Or, type info() for more options.

| View the class of t1 with class(t1).

> class(t1)
[1] "POSIXct" "POSIXt" 

| You're the best!

  |                                                                                                                                                                     |=========================================================                                                                                                    |  36%
| As mentioned earlier, POSIXct is just one of two ways that R represents time information. (You can ignore the second value above, POSIXt, which just functions as a
| common language between POSIXct and POSIXlt.) Use unclass() to see what t1 looks like internally -- the (large) number of seconds since the beginning of 1970.

> unclass(t1)
[1] 1489350145

| You're the best!

  |                                                                                                                                                                     |=============================================================                                                                                                |  39%
| By default, Sys.time() returns an object of class POSIXct, but we can coerce the result to POSIXlt with as.POSIXlt(Sys.time()). Give it a try and store the result
| in t2.

> t2<-as.POSIXlt(Sys.time)
Error in as.POSIXlt.default(Sys.time) : 
  do not know how to convert 'Sys.time' to class “POSIXlt”
> t2<-as.POSIXlt(Sys.time())

| You nailed it! Good job!

  |                                                                                                                                                                     |=================================================================                                                                                            |  42%
| Check the class of t2.

> class(t2)
[1] "POSIXlt" "POSIXt" 

| That's correct!

  |                                                                                                                                                                     |======================================================================                                                                                       |  44%
| Now view its contents.

> t2
[1] "2017-03-12 22:25:18 IST"

| You are doing so well!

  |                                                                                                                                                                     |==========================================================================                                                                                   |  47%
| The printed format of t2 is identical to that of t1. Now unclass() t2 to see how it is different internally.

> unclass(t2)
$sec
[1] 18.78491

$min
[1] 25

$hour
[1] 22

$mday
[1] 12

$mon
[1] 2

$year
[1] 117

$wday
[1] 0

$yday
[1] 70

$isdst
[1] 0

$zone
[1] "IST"

$gmtoff
[1] 7200

attr(,"tzone")
[1] ""    "IST" "IDT"

| You are really on a roll!

  |                                                                                                                                                                     |==============================================================================                                                                               |  50%
| t2, like all POSIXlt objects, is just a list of values that make up the date and time. Use str(unclass(t2)) to have a more compact view.

> str(unclass(t2))
List of 11
 $ sec   : num 18.8
 $ min   : int 25
 $ hour  : int 22
 $ mday  : int 12
 $ mon   : int 2
 $ year  : int 117
 $ wday  : int 0
 $ yday  : int 70
 $ isdst : int 0
 $ zone  : chr "IST"
 $ gmtoff: int 7200
 - attr(*, "tzone")= chr [1:3] "" "IST" "IDT"

| Perseverance, that's the answer.

  |                                                                                                                                                                     |===================================================================================                                                                          |  53%
| If, for example, we want just the minutes from the time stored in t2, we can access them with t2$min. Give it a try.

> t2$min
[1] 25

| All that hard work is paying off!

  |                                                                                                                                                                     |=======================================================================================                                                                      |  56%
| Now that we have explored all three types of date and time objects, let's look at a few functions that extract useful information from any of these objects --
| weekdays(), months(), and quarters().

...

  |                                                                                                                                                                     |============================================================================================                                                                 |  58%
| The weekdays() function will return the day of week from any date or time object. Try it out on d1, which is the Date object that contains today's date.

> weekdays(d1)
[1] "éåí øàùåï"

| Perseverance, that's the answer.

  |                                                                                                                                                                     |================================================================================================                                                             |  61%
| The months() function also works on any date or time object. Try it on t1, which is the POSIXct object that contains the current time (well, it was the current time
| when you created it).

> months(t1)
[1] "îøõ"

| All that hard work is paying off!

  |                                                                                                                                                                     |====================================================================================================                                                         |  64%
| The quarters() function returns the quarter of the year (Q1-Q4) from any date or time object. Try it on t2, which is the POSIXlt object that contains the time at
| which you created it.

> quarters(t2)
[1] "Q1"

| You are amazing!

  |                                                                                                                                                                     |=========================================================================================================                                                    |  67%
| Often, the dates and times in a dataset will be in a format that R does not recognize. The strptime() function can be helpful in this situation.

...

  |                                                                                                                                                                     |=============================================================================================================                                                |  69%
| strptime() converts character vectors to POSIXlt. In that sense, it is similar to as.POSIXlt(), except that the input doesn't have to be in a particular format
| (YYYY-MM-DD).

...

  |                                                                                                                                                                     |=================================================================================================================                                            |  72%
| To see how it works, store the following character string in a variable called t3: "October 17, 1986 08:24" (with the quotes).

> t3<-"October 17, 1986 08:24"

| You are quite good my friend!

  |                                                                                                                                                                     |======================================================================================================================                                       |  75%
| Now, use strptime(t3, "%B %d, %Y %H:%M") to help R convert our date/time object to a format that it understands. Assign the result to a new variable called t4. (You
| should pull up the documentation for strptime() if you'd like to know more about how it works.)

> t4<-strptime(t3,"%B %d %Y %H:%M")

| Give it another try. Or, type info() for more options.

| t4 <- strptime(t3, "%B %d, %Y %H:%M") will convert our date/time object to a format that R understands.

> t4<-strptime(t3, "%B %d, %Y %H:%M")

| All that practice is paying off!

  |                                                                                                                                                                     |==========================================================================================================================                                   |  78%
| Print the contents of t4.

> t4
[1] NA

| You are really on a roll!

  |                                                                                                                                                                     |==============================================================================================================================                               |  81%
| That's the format we've come to expect. Now, let's check its class().

> class(t4)
[1] "POSIXlt" "POSIXt" 

| You are quite good my friend!

  |                                                                                                                                                                     |===================================================================================================================================                          |  83%
| Finally, there are a number of operations that you can perform on dates and times, including arithmetic operations (+ and -) and comparisons (<, ==, etc.)

...

  |                                                                                                                                                                     |=======================================================================================================================================                      |  86%
| The variable t1 contains the time at which you created it (recall you used Sys.time()). Confirm that some time has passed since you created t1 by using the 'greater
| than' operator to compare it to the current time: Sys.time() > t1

> t1<Sys.time()
[1] TRUE

| Nice try, but that's not exactly what I was hoping for. Try again. Or, type info() for more options.

| Sys.time() > t1 will tell you that the current time is after the time contained in t1 (which was the current time when you created it).

> Sys.time()>t1
[1] TRUE

| Great job!

  |                                                                                                                                                                     |============================================================================================================================================                 |  89%
| So we know that some time has passed, but how much? Try subtracting t1 from the current time using Sys.time() - t1. Don't forget the parentheses at the end of
| Sys.time(), since it is a function.

> Sys.time()-t1
Time difference of 12.12787 hours

| You are quite good my friend!

  |                                                                                                                                                                     |================================================================================================================================================             |  92%
| The same line of thinking applies to addition and the other comparison operators. If you want more control over the units when finding the above difference in
| times, you can use difftime(), which allows you to specify a 'units' parameter.

...

  |                                                                                                                                                                     |====================================================================================================================================================         |  94%
| Use difftime(Sys.time(), t1, units = 'days') to find the amount of time in DAYS that has passed since you created t1.

> difftime(Sys.time(),t1,units='days')
Time difference of 0.5059624 days

| All that practice is paying off!

  |                                                                                                                                                                     |=========================================================================================================================================================    |  97%
| In this lesson, you learned how to work with dates and times in R. While it is important to understand the basics, if you find yourself working with dates and times
| often, you may want to check out the lubridate package by Hadley Wickham.

...

  |                                                                                                                                                                     |=============================================================================================================================================================| 100%
| Would you like to receive credit for completing this course on Coursera.org?

1: Yes
2: No

Selection: 1
What is your email address? roee.orland@gmail.com
What is your assignment token? 8lUTAmgOwMblUwGN
Grade submission succeeded!

| You nailed it! Good job!

| You've reached the end of this lesson! Returning to the main menu...

| Please choose a course, or type 0 to exit swirl.

1: R Programming
2: Take me to the swirl course repository!

Selection: 
Enter an item from the menu, or 0 to exit
Selection: 1

| Please choose a lesson, or type 0 to return to course menu.

 1: Basic Building Blocks      2: Workspace and Files        3: Sequences of Numbers       4: Vectors                    5: Missing Values          
 6: Subsetting Vectors         7: Matrices and Data Frames   8: Logic                      9: Functions                 10: lapply and sapply       
11: vapply and tapply         12: Looking at Data           13: Simulation                14: Dates and Times           15: Base Graphics           


Selection: 8

  |                                                                                                                                                                     |                                                                                                                                                             |   0%

| This lesson is meant to be a short introduction to logical operations in R.

...

  |                                                                                                                                                                     |===                                                                                                                                                          |   2%
| There are two logical values in R, also called boolean values. They are TRUE and FALSE. In R you can construct logical expressions which will evaluate to either
| TRUE or FALSE.

...

  |                                                                                                                                                                     |======                                                                                                                                                       |   4%
| Many of the questions in this lesson will involve evaluating logical expressions. It may be useful to open up a second R terminal where you can experiment with some
| of these expressions.

...

  |                                                                                                                                                                     |=========                                                                                                                                                    |   6%
| Creating logical expressions requires logical operators. You're probably familiar with arithmetic operators like `+`, `-`, `*`, and `/`. The first logical operator
| we are going to discuss is the equality operator, represented by two equals signs `==`. Use the equality operator below to find out if TRUE is equal to TRUE.

> TRUE==TRUE
[1] TRUE

| You nailed it! Good job!

  |                                                                                                                                                                     |============                                                                                                                                                 |   8%
| Just like arithmetic, logical expressions can be grouped by parenthesis so that the entire expression (TRUE == TRUE) == TRUE evaluates to TRUE.

...

  |                                                                                                                                                                     |===============                                                                                                                                              |  10%
| To test out this property, try evaluating (FALSE == TRUE) == FALSE .

> (FALSE==TRUE)==FALSE
[1] TRUE

| You are really on a roll!

  |                                                                                                                                                                     |==================                                                                                                                                           |  12%
| The equality operator can also be used to compare numbers. Use `==` to see if 6 is equal to 7.

> 6==7
[1] FALSE

| You're the best!

  |                                                                                                                                                                     |=====================                                                                                                                                        |  13%
| The previous expression evaluates to FALSE because 6 is less than 7. Thankfully, there are inequality operators that allow us to test if a value is less than or
| greater than another value.

...

  |                                                                                                                                                                     |========================                                                                                                                                     |  15%
| The less than operator `<` tests whether the number on the left side of the operator (called the left operand) is less than the number on the right side of the
| operator (called the right operand). Write an expression to test whether 6 is less than 7.

> 6<7
[1] TRUE

| Perseverance, that's the answer.

  |                                                                                                                                                                     |===========================                                                                                                                                  |  17%
| There is also a less-than-or-equal-to operator `<=` which tests whether the left operand is less than or equal to the right operand. Write an expression to test
| whether 10 is less than or equal to 10.

> 10<=10
[1] TRUE

| Keep working like that and you'll get there!

  |                                                                                                                                                                     |==============================                                                                                                                               |  19%
| Keep in mind that there are the corresponding greater than `>` and greater-than-or-equal-to `>=` operators.

...

  |                                                                                                                                                                     |=================================                                                                                                                            |  21%
| Which of the following evaluates to FALSE?

1: 0 > -36
2: 6 < 8
3: 7 == 7
4: 9 >= 10

Selection: 4

| You got it right!

  |                                                                                                                                                                     |====================================                                                                                                                         |  23%
| Which of the following evaluates to TRUE?

1: 57 < 8
2: -6 > -7
3: 7 == 9
4: 9 >= 10

Selection: 2

| All that hard work is paying off!

  |                                                                                                                                                                     |=======================================                                                                                                                      |  25%
| The next operator we will discuss is the 'not equals' operator represented by `!=`. Not equals tests whether two values are unequal, so TRUE != FALSE evaluates to
| TRUE. Like the equality operator, `!=` can also be used with numbers. Try writing an expression to see if 5 is not equal to 7.

> 5!=7
[1] TRUE

| That's a job well done!

  |                                                                                                                                                                     |==========================================                                                                                                                   |  27%
| In order to negate boolean expressions you can use the NOT operator. An exclamation point `!` will cause !TRUE (say: not true) to evaluate to FALSE and !FALSE (say:
| not false) to evaluate to TRUE. Try using the NOT operator and the equals operator to find the opposite of whether 5 is equal to 7.

> !(5==7)
[1] TRUE

| You are really on a roll!

  |                                                                                                                                                                     |=============================================                                                                                                                |  29%
| Let's take a moment to review. The equals operator `==` tests whether two boolean values or numbers are equal, the not equals operator `!=` tests whether two
| boolean values or numbers are unequal, and the NOT operator `!` negates logical expressions so that TRUE expressions become FALSE and FALSE expressions become TRUE.

...

  |                                                                                                                                                                     |================================================                                                                                                             |  31%
| Which of the following evaluates to FALSE?

1: !FALSE
2: 9 < 10
3: !(0 >= -1)
4: 7 != 8

Selection: 3

| You are doing so well!

  |                                                                                                                                                                     |===================================================                                                                                                          |  33%
| What do you think the following expression will evaluate to?: (TRUE != FALSE) == !(6 == 7)

1: FALSE
2: TRUE
3: %>%
4: Can there be objective truth when programming?

Selection: 2

| You are really on a roll!

  |                                                                                                                                                                     |======================================================                                                                                                       |  35%
| At some point you may need to examine relationships between multiple logical expressions. This is where the AND operator and the OR operator come in.

...

  |                                                                                                                                                                     |=========================================================                                                                                                    |  37%
| Let's look at how the AND operator works. There are two AND operators in R, `&` and `&&`. Both operators work similarly, if the right and left operands of AND are
| both TRUE the entire expression is TRUE, otherwise it is FALSE. For example, TRUE & TRUE evaluates to TRUE. Try typing FALSE & FALSE to how it is evaluated.

> FALSE&FALSE
[1] FALSE

| You are really on a roll!

  |                                                                                                                                                                     |============================================================                                                                                                 |  38%
| You can use the `&` operator to evaluate AND across a vector. The `&&` version of AND only evaluates the first member of a vector. Let's test both for practice.
| Type the expression TRUE & c(TRUE, FALSE, FALSE).

> TRUE & c(TRUE,FALSE,FALSE)
[1]  TRUE FALSE FALSE

| All that practice is paying off!

  |                                                                                                                                                                     |===============================================================                                                                                              |  40%
| What happens in this case is that the left operand `TRUE` is recycled across every element in the vector of the right operand. This is the equivalent statement as
| c(TRUE, TRUE, TRUE) & c(TRUE, FALSE, FALSE).

...

  |                                                                                                                                                                     |==================================================================                                                                                           |  42%
| Now we'll type the same expression except we'll use the `&&` operator. Type the expression TRUE && c(TRUE, FALSE, FALSE).

> TRUE && c(TRUE,FALSE,FALSE)
[1] TRUE

| Your dedication is inspiring!

  |                                                                                                                                                                     |=====================================================================                                                                                        |  44%
| In this case, the left operand is only evaluated with the first member of the right operand (the vector). The rest of the elements in the vector aren't evaluated at
| all in this expression.

...

  |                                                                                                                                                                     |========================================================================                                                                                     |  46%
| The OR operator follows a similar set of rules. The `|` version of OR evaluates OR across an entire vector, while the `||` version of OR only evaluates the first
| member of a vector.

...

  |                                                                                                                                                                     |===========================================================================                                                                                  |  48%
| An expression using the OR operator will evaluate to TRUE if the left operand or the right operand is TRUE. If both are TRUE, the expression will evaluate to TRUE,
| however if neither are TRUE, then the expression will be FALSE.

...

  |                                                                                                                                                                     |==============================================================================                                                                               |  50%
| Let's test out the vectorized version of the OR operator. Type the expression TRUE | c(TRUE, FALSE, FALSE).

> TRUE | c(TRUE,FALSE,FALSE)
[1] TRUE TRUE TRUE

| You got it right!

  |                                                                                                                                                                     |==================================================================================                                                                           |  52%
| Now let's try out the non-vectorized version of the OR operator. Type the expression TRUE || c(TRUE, FALSE, FALSE).

> TRUE || c(TRUE,FALSE,FALSE)
[1] TRUE

| That's the answer I was looking for.

  |                                                                                                                                                                     |=====================================================================================                                                                        |  54%
| Logical operators can be chained together just like arithmetic operators. The expressions: `6 != 10 && FALSE && 1 >= 2` or `TRUE || 5 < 9.3 || FALSE` are perfectly
| normal to see.

...

  |                                                                                                                                                                     |========================================================================================                                                                     |  56%
| As you may recall, arithmetic has an order of operations and so do logical expressions. All AND operators are evaluated before OR operators. Let's look at an
| example of an ambiguous case. Type: 5 > 8 || 6 != 8 && 4 > 3.9

> 5>8||6!=8 && 4>3.9
[1] TRUE

| Your dedication is inspiring!

  |                                                                                                                                                                     |===========================================================================================                                                                  |  58%
| Let's walk through the order of operations in the above case. First the left and right operands of the AND operator are evaluated. 6 is not equal 8, 4 is greater
| than 3.9, therefore both operands are TRUE so the resulting expression `TRUE && TRUE` evaluates to TRUE. Then the left operand of the OR operator is evaluated: 5 is
| not greater than 8 so the entire expression is reduced to FALSE || TRUE. Since the right operand of this expression is TRUE the entire expression evaluates to TRUE.

...

  |                                                                                                                                                                     |==============================================================================================                                                               |  60%
| Which one of the following expressions evaluates to TRUE?

1: TRUE && FALSE || 9 >= 4 && 3 < 6
2: TRUE && 62 < 62 && 44 >= 44
3: FALSE || TRUE && FALSE
4: 99.99 > 100 || 45 < 7.3 || 4 != 4.0

Selection: 1

| All that practice is paying off!

  |                                                                                                                                                                     |=================================================================================================                                                            |  62%
| Which one of the following expressions evaluates to FALSE?

1: FALSE && 6 >= 6 || 7 >= 8 || 50 <= 49.5
2: 6 >= -9 && !(6 > 7) && !(!TRUE)
3: FALSE || TRUE && 6 != 4 || 9 > 4
4: !(8 > 4) ||  5 == 5.0 && 7.8 >= 7.79

Selection: 4

| Give it another try.

| Try to evaluate each expression in isolation and build up an answer.

1: FALSE || TRUE && 6 != 4 || 9 > 4
2: !(8 > 4) ||  5 == 5.0 && 7.8 >= 7.79
3: 6 >= -9 && !(6 > 7) && !(!TRUE)
4: FALSE && 6 >= 6 || 7 >= 8 || 50 <= 49.5

Selection: 
Enter an item from the menu, or 0 to exit
Selection: 4

| That's the answer I was looking for.

  |                                                                                                                                                                     |====================================================================================================                                                         |  63%
| Now that you're familiar with R's logical operators you can take advantage of a few functions that R provides for dealing with logical expressions.

...

  |                                                                                                                                                                     |=======================================================================================================                                                      |  65%
| The function isTRUE() takes one argument. If that argument evaluates to TRUE, the function will return TRUE. Otherwise, the function will return FALSE. Try using
| this function by typing: isTRUE(6 > 4)

> isTRUE(6>4)
[1] TRUE

| You are quite good my friend!

  |                                                                                                                                                                     |==========================================================================================================                                                   |  67%
| Which of the following evaluates to TRUE?

1: isTRUE(NA)
2: isTRUE(3)
3: isTRUE(!TRUE)
4: !isTRUE(8 != 5)
5: !isTRUE(4 < 3)

Selection: 5

| Your dedication is inspiring!

  |                                                                                                                                                                     |=============================================================================================================                                                |  69%
| The function identical() will return TRUE if the two R objects passed to it as arguments are identical. Try out the identical() function by typing:
| identical('twins', 'twins')

> identical('twins','twins')
[1] TRUE

| You're the best!

  |                                                                                                                                                                     |================================================================================================================                                             |  71%
| Which of the following evaluates to TRUE?

1: identical(5 > 4, 3 < 3.1)
2: identical(4, 3.1)
3: identical('hello', 'Hello')
4: !identical(7, 7)

Selection: 1

| Nice work!

  |                                                                                                                                                                     |===================================================================================================================                                          |  73%
| You should also be aware of the xor() function, which takes two arguments. The xor() function stands for exclusive OR. If one argument evaluates to TRUE and one
| argument evaluates to FALSE, then this function will return TRUE, otherwise it will return FALSE. Try out the xor() function by typing: xor(5 == 6, !FALSE)

> xor(5==6,!FALSE)
[1] TRUE

| Excellent job!

  |                                                                                                                                                                     |======================================================================================================================                                       |  75%
| 5 == 6 evaluates to FALSE, !FALSE evaluates to TRUE, so xor(FALSE, TRUE) evaluates to TRUE. On the other hand if the first argument was changed to 5 == 5 and the
| second argument was unchanged then both arguments would have been TRUE, so xor(TRUE, TRUE) would have evaluated to FALSE.

...

  |                                                                                                                                                                     |=========================================================================================================================                                    |  77%
| Which of the following evaluates to FALSE?

1: xor(!!TRUE, !!FALSE)
2: xor(identical(xor, 'xor'), 7 == 7.0)
3: xor(!isTRUE(TRUE), 6 > -1)
4: xor(4 >= 9, 8 != 8.0)

Selection: 1

| Keep trying!

| For xor() to evaluate to TRUE, one argument must be TRUE and one must be FALSE.

1: xor(4 >= 9, 8 != 8.0)
2: xor(identical(xor, 'xor'), 7 == 7.0)
3: xor(!!TRUE, !!FALSE)
4: xor(!isTRUE(TRUE), 6 > -1)

Selection: 1

| Nice work!

  |                                                                                                                                                                     |============================================================================================================================                                 |  79%
| For the next few questions, we're going to need to create a vector of integers called ints. Create this vector by typing: ints <- sample(10)

> ints<-sample(10)

| You got it right!

  |                                                                                                                                                                     |===============================================================================================================================                              |  81%
| Now simply display the contents of ints.

> ints
 [1] 10  5  4  6  8  7  1  9  2  3

| Great job!

  |                                                                                                                                                                     |==================================================================================================================================                           |  83%
| The vector `ints` is a random sampling of integers from 1 to 10 without replacement. Let's say we wanted to ask some logical questions about contents of ints. If we
| type ints > 5, we will get a logical vector corresponding to whether each element of ints is greater than 5. Try typing: ints > 5

> ints>5
 [1]  TRUE FALSE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE

| Excellent job!

  |                                                                                                                                                                     |=====================================================================================================================================                        |  85%
| We can use the resulting logical vector to ask other questions about ints. The which() function takes a logical vector as an argument and returns the indices of the
| vector that are TRUE. For example which(c(TRUE, FALSE, TRUE)) would return the vector c(1, 3).

...

  |                                                                                                                                                                     |========================================================================================================================================                     |  87%
| Use the which() function to find the indices of ints that are greater than 7.

> which(ints>7)
[1] 1 5 8

| You are quite good my friend!

  |                                                                                                                                                                     |===========================================================================================================================================                  |  88%
| Which of the following commands would produce the indices of the elements in ints that are less than or equal to 2?

1: ints < 2
2: ints <= 2
3: which(ints < 2)
4: which(ints <= 2)

Selection: 4

| You got it!

  |                                                                                                                                                                     |==============================================================================================================================================               |  90%
| Like the which() function, the functions any() and all() take logical vectors as their argument. The any() function will return TRUE if one or more of the elements
| in the logical vector is TRUE. The all() function will return TRUE if every element in the logical vector is TRUE.

...

  |                                                                                                                                                                     |=================================================================================================================================================            |  92%
| Use the any() function to see if any of the elements of ints are less than zero.

> any(ints<0)
[1] FALSE

| That's correct!

  |                                                                                                                                                                     |====================================================================================================================================================         |  94%
| Use the all() function to see if all of the elements of ints are greater than zero.

> all(ints>0)
[1] TRUE

| That's correct!

  |                                                                                                                                                                     |=======================================================================================================================================================      |  96%
| Which of the following evaluates to TRUE?

1: any(ints == 10)
2: all(c(TRUE, FALSE, TRUE))
3: all(ints == 10)
4: any(ints == 2.5)

Selection: 1

| Keep working like that and you'll get there!

  |                                                                                                                                                                     |==========================================================================================================================================================   |  98%
| That's all for this introduction to logic in R. If you really want to see what you can do with logic, check out the control flow lesson!

...

  |                                                                                                                                                                     |=============================================================================================================================================================| 100%
| Would you like to receive credit for completing this course on Coursera.org?

1: No
2: Yes

Selection: 2
What is your email address? roee.orland@gmail.com
What is your assignment token? V0aTYCkIrEhzYvbM
Grade submission succeeded!

| You got it right!

| You've reached the end of this lesson! Returning to the main menu...

| Please choose a course, or type 0 to exit swirl.

1: R Programming
2: Take me to the swirl course repository!

Selection: 1

| Please choose a lesson, or type 0 to return to course menu.

 1: Basic Building Blocks      2: Workspace and Files        3: Sequences of Numbers       4: Vectors                    5: Missing Values          
 6: Subsetting Vectors         7: Matrices and Data Frames   8: Logic                      9: Functions                 10: lapply and sapply       
11: vapply and tapply         12: Looking at Data           13: Simulation                14: Dates and Times           15: Base Graphics           


Selection: 9

  |                                                                                                                                                                     |                                                                                                                                                             |   0%

| Functions are one of the fundamental building blocks of the R language. They are small pieces of reusable code that can be treated like any other R object.

...
